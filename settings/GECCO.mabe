random_seed = 0;       // Seed for random number generator; use 0 to base on time.
Population main_pop;            // Collection of organisms
Population next_pop;            // Collection of organisms
Value pop_size = 200;           // Local value variable.
CommandLine cl {                // Handle basic I/O on the command line.
  format = "fitness:max,fitness:mean";// Column format to use in the file.
  target = "main_pop";          // Which population(s) should we print from?
}
AnalyzeSystematics sys {        // Module to track the population's phylogeny.
  store_outside = 0;            // Store all taxa that ever existed.(1 = TRUE)
  store_ancestors = 1;          // Store all ancestors of extant taxa.(1 = TRUE)
  taxon_info = "vals";    // Which trait should we identify unique taxa based on
  data_file_name = "phylogenetic_data.csv";// Filename for systematics data file.
  snapshot_file_root_name = "phylogeny";// Filename for snapshot files (will have update number and .csv appended to end)
  snapshot_updates = "0:1000";    // Which updates should we output a snapshot of the phylogeny?
  data_updates = "-1:-1";       // Which updates should we output a data from the phylogeny?
}
EvalGECCO eval_gecco {          // Evaluate bitstrings on a 3D GECCO niching lanscape.
  target = "main_pop";          // Which population(s) should we evaluate?
  fcn_name = "Shubert";         // Which function should we use? [Shubert, Vincent, CF3, CF4]
  dims = 3;                     // How many dimensions should the fitness function have? [2, 3]
  vals_trait = "vals";          // Which trait stores the 3-tuple to evaluate?
  fitness_trait = "fitness";    // Which trait should we store fitness in?
  genome_file = "genome.csv";   // Where should we output the genome?
  dat_path = "./../source/tools/DataGECCO/";// Where do we pull the .dat files for the composite functions?
}
FileOutput output {             // Output collected data into a specified file.
  filename = "output.csv";      // Name of file for output data.
  format = "fitness:max,fitness:mean";// Column format to use in the file.
  target = "main_pop";          // Which population(s) should we print from?
  output_updates = "0:1";       // Which updates should we output data?
}
SelectElite select_elite {      // Choose the top fitness organisms for replication.
  select_pop = "main_pop";      // Which population should we select parents from?
  birth_pop = "next_pop";       // Which population should births go into?
  top_count = 1;                // Number of top-fitness orgs to be replicated
  copy_count = 1;               // Number of copies to make of replicated organisms
  fitness_trait = "fitness";    // Which trait provides the fitness value to use?
}
SelectTournament select_tourny { // Select the top fitness organisms from random subgroups for replication.
  select_pop = "main_pop";      // Population from which to select parents
  birth_pop = "next_pop";       // Population into which offspring should be placed
  tournament_size =  7;         // Number of orgs in each tournament
  num_tournaments = pop_size - select_elite.copy_count;         // Number of tournaments to run
  fitness_fun = "fitness";      // Trait equation that produces fitness value to use
}
GrowthPlacement place_next {    // Always appened births to the end of a population.
  target = "main_pop,next_pop"; // Population(s) to manage.
}
MovePopulation sync_gen {       // Move organisms from one populaiton to another.
  from_pop = "next_pop";        // Population to move organisms from.
  to_pop = "main_pop";          // Population to move organisms into.
  reset_to = 1;                 // Should we erase organisms at the destination?
}
ValsOrg vals_org {              // Organism consisting of a series of N floating-point values.
  N = eval_gecco.dims;                      // Number of values in organism
  mut_prob = 0.01;              // Probability of each value mutating on reproduction.
  mut_size = 1;                 // Standard deviation on size of mutations.
  min_value = 0;                // Lower limit for value fields.
  max_value = 100;              // Upper limit for value fields.
  lower_bound = "rebound";      // How should the lower limit be enforced?
                                //  no_limit: Allow values to be arbirarily low.
                                //  clamp: Reduce too-low values to min_value.
                                //  wrap: Make low values loop around to maximum.
                                //  rebound: Make low values 'bounce' back up.
  upper_bound = "rebound";      // How should the upper limit be enforced?
                                //  no_limit: Allow values to be arbirarily high.
                                //  clamp: Reduce too-high values to max_value.
                                //  wrap: Make high values loop around to minimum.
                                //  rebound: Make high values 'bounce' back down.
  output_name = "vals";         // Name of variable to contain set of values.
  total_name = "total";         // Name of variable to contain total of all values.
  init_random = 1;              // Should we randomize ancestor?  (0 = all 0.0)
}

@start(0) PRINT("random_seed = ", random_seed, "\n");
@start(0) INJECT("vals_org", "main_pop", pop_size);
@update(1000) EXIT();
